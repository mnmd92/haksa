/**
 * fsp 사용 준비.
 */
if ( typeof fsp === "undefined") {
	var fsp = {		
	};
}

/**
 * 처리 요청 목록 정보.<p>
 */
fsp.fsp_ds_cmd = [];

/**
 * 처리할 서버 url.<p>
 */
fsp.serverUrl = 'https://nsugang.kangwon.ac.kr/sugang/JSONMain';

/**
 * 캠퍼스 구분을 가져온다.
 * @returns {String} 캠퍼스 구분 코드 
 */
fsp.getCampus = function() {
	return "C";	// 삼척 
};

/**
 * 접속하는 서버 경로를 변경한다.<p>
 */
fsp.changeServerUrl = function(strUrl) {
	if( strUrl ) {
		fsp.serverUrl = strUrl;
	}
};

/**
 * 정보를 초기화 한다.<p>
 */
fsp.clear = function() {
	fsp.fsp_ds_cmd = [];
};

/**
	* 자바 코딩 없이 사용할 경우 서버에서 처리하기 위한 Action 호출 
	* 정보를 추가
	* @param txType 호출하는 Transaction 타입 
	         S - Insert, Update , Delete 동시 처리 
	         M - 주어진 SQL 정보에 대해 Dataset이 존재하는 건 만큼 반복처리 
	         CSV - 조회용 SQL 만 가능하며, 데이터 조회 후 CSV 형태로 데이터를 넘겨 줌.
	* @param sqlName 처리할 Main SQL ID
	                 txType이 'S'인 경우에는 해당 sql은 사용되지 않는다. 
	* @param keySqlName PK 조회용 SQL ID 
	* @param keyIncrement keySqlName이 존재할 경우만 사용되며, 
	                      반복적인 처리 Sql의 경우 다음 정보 key 증가 값 
	                      현재는 integer 형의 숫자형 key만 처리 가능 
	* @param callbackSql 처리가 완료된 후 결과로써 반환할 Sql Id 
	* @param insertSql  txType이 'S'인 경우 또는 sqlName 파라메터가 존재하면서 해당하는 
	                    main sql에 대해서 master-detail 구조일 경우 
	                    insert를 처리할 SQL ID 
	* @param updateSql  txType이 'S'인 경우 또는 sqlName 파라메터가 존재하면서 해당하는 
	                    main sql에 대해서 master-detail 구조일 경우 
	                    update를 처리할 SQL ID            
	* @param deleteSql  txType이 'S'인 경우 또는 sqlName 파라메터가 존재하면서 해당하는 
	                    main sql에 대해서 master-detail 구조일 경우 
	                    delete를 처리할 SQL ID     
	* @param saveFlagColumn  insertSql, updateSql, deleteSql이 존재하여 신규, 수정, 삭제를 
	                         처리할 경우 기본적으로 Dataset의 getRowStates()로 판단하여 처리
	                         하나 이를 Flag 컬럼으로 대체하고 싶은 경우 사용
	                         해당 Flag 컬럼의 값은 신규 - I , 수정 - U , 삭제 - D의 값을 
	                         가져야 한다. 
	* @return 없음
 */
fsp.add = function(txType
 		, sqlName
 		, keySqlName
 		, keyIncrement
 		, callbackSql
	    , insertSql
	    , updateSql
	    , deleteSql
	    , saveFlagColumn
	    , keyZeroLen
	    , execType
	    , otherOptions ) {
	var obj = {
			TYPE : txType
			, SQL_ID : sqlName
			, KEY_SQL_ID : keySqlName
			, KEY_INCREMENT : keyIncrement
			, CALLBACK_SQL_ID : callbackSql
			, INSERT_SQL_ID : insertSql
			, UPDATE_SQL_ID : updateSql
			, DELETE_SQL_ID : deleteSql
			, SAVE_FLAG_COLUMN : saveFlagColumn
			, KEY_ZERO_LEN : keyZeroLen
			, EXEC_TYPE : ( fsp.isUndefined(execType)? "B" : execType)
			, USE_INPUT : "N"
			, USE_ORDER : "Y"
			// return 되는 정보 
			, EXEC : ""
			, FAIL : ""
			, FAIL_MSG : ""
			, EXEC_CNT : 0
			, MSG : ""
	};
	
	if( otherOptions ) {
		if( otherOptions.isUseInput ) {
			obj["USE_INPUT"] = "Y";
		}
		
		if( otherOptions.isNotUseOrder) {
			obj["USE_ORDER"] = "N";
		}
	}
	
	fsp.fsp_ds_cmd[fsp.fsp_ds_cmd.length] = obj;
};

/*****************************************************************
* 조회용 Action 정보 생성 ( 자바 코드 없이 사용할 경우 )
* @param sqlName 조회할 SQL ID 
* @param isUseInput 조회한 결과는 Input Dataset으로 사용할지 여부 
* @param isNotUseOrder Dataset 컬럼 생성시 정렬할지 여부  
* @return 없음
******************************************************************/
fsp.addSearch = function (sqlName, isUseInput, isNotUseOrder, rtnDsId) {
	var otherOptions = {
			isUseInput : fsp.isUndefined(isUseInput, false, true)
			, isNotUseOrder : fsp.isUndefined(isNotUseOrder, false, true)
	};
    
	fsp.add("N" // txType
			, sqlName // sqlName 
			, "" // keySqlName	
	        , ""	// keyIncrement
	        , ""	// callbackSql
	        , ""	// insertSql
	        , ""	// updateSql
	        , ""	// deleteSql
	        , rtnDsId	// saveFlagColumn
	        , null 		// keyZeroLen
	        , null		// execType
	        , otherOptions
	);
};
/*****************************************************************
* 페이지 단위 조회용 Action 정보 생성 ( 자바 코드 없이 사용할 경우 )
* @param sqlName 조회할 SQL ID 
* @param pageNo 페이지 번호 
* @param pageSize 페이지 사이즈 
* @param isAllRead 주어진 페이지 이후로 전체 데이터를 읽을지 유무 
* @param isUseInput 조회한 결과는 Input Dataset으로 사용할지 여부 
* @param isNotUseOrder Dataset 컬럼 생성시 정렬할지 여부  
* @return 없음
******************************************************************/
fsp.addPageSearch = function( sqlName, pageNo, pageSize, isAllRead, isUseInput, isNotUseOrder ) {
	fsp.addSearch(sqlName, isUseInput, isNotUseOrder );
	
	var obj = fsp.fsp_ds_cmd[fsp.fsp_ds_cmd.length-1];
	
	if( isAllRead === true ) {
		obj["READ_ALL"] = "Y";
	} else {
		obj["READ_ALL"] = "N";
	}
	
	obj["PAGE_NO"] = pageNo;
	obj["PAGE_SIZE"] = pageSize;
};

/*****************************************************************
* 단일 처리 Action 정보 생성 
* @param sqlName 단일 처리 SQL ID 
* @param keySqlName PK 조회용 SQL ID 
* @param keyIncrement keySqlName이 존재할 경우만 사용되며, 
                      반복적인 처리 Sql의 경우 다음 정보 key 증가 값 
                      현재는 integer 형의 숫자형 key만 처리 가능 
* @param callbackSql 처리가 완료된 후 결과로써 반환할 Sql Id 
* @param execType 처리해야 하는 실행타입 정의 ( B - 배치 , N - 한건 씩 처리 )
* @return 없음
******************************************************************/
fsp.addSingle = function(
		sqlName
		, keySqlName
		, keyIncrement
		, callbackSql
		, execType) {
	
	fsp.add("N" // txType
			, sqlName // sqlName 
			, keySqlName // keySqlName	
	        , keyIncrement	// keyIncrement
	        , callbackSql	// callbackSql
	        , ""	// insertSql
	        , ""	// updateSql
	        , ""	// deleteSql
	        , ""	// saveFlagColumn
	        , "" 		// keyZeroLen
	        , execType		// execType
	);
};

/*****************************************************************
* 주어진 SQL을 Dataset 건수 만큼 반복적으로 처리하는 action 정보 생성 
* @param sqlName  처리할 SQL 
* @param keySqlName  Key SQL이 존재할 경우 SQL ID          
* @param keyIncrement  Key 증가 값 
* @param callbackSql  처리 완료 후 반환할 정보를 조회할 SQL ID   
* @param keyZeroLen  Key 에 0 채워야 할 경우 0 의 갯수 
* @param execType 처리해야 하는 실행타입 정의 ( B - 배치 , N - 한건 씩 처리 )
* @return 없음
******************************************************************/
fsp.addMulti = function(
		sqlName
		, keySqlName
		, keyIncrement
		, callbackSql
		, keyZeroLen
		, execType) {
	
	fsp.add("M" // txType
			, sqlName // sqlName 
			, keySqlName // keySqlName	
	        , keyIncrement	// keyIncrement
	        , callbackSql	// callbackSql
	        , ""	// insertSql
	        , ""	// updateSql
	        , ""	// deleteSql
	        , ""	// saveFlagColumn
	        , keyZeroLen 		// keyZeroLen
	        , execType		// execType
	);
};

/*****************************************************************
* SaveAction 정보 생성 ( getRowType() 또는 주어진 Flat 컬럼의 값을 읽어 
  등록, 수정, 삭제를 처리는 SQL 요청 정보 생성 )
* @param insertSql  txType이 'S'인 경우 또는 sqlName 파라메터가 존재하면서 해당하는 
                    main sql에 대해서 master-detail 구조일 경우 
                    insert를 처리할 SQL ID 
* @param updateSql  txType이 'S'인 경우 또는 sqlName 파라메터가 존재하면서 해당하는 
                    main sql에 대해서 master-detail 구조일 경우 
                    update를 처리할 SQL ID            
* @param deleteSql  txType이 'S'인 경우 또는 sqlName 파라메터가 존재하면서 해당하는 
                    main sql에 대해서 master-detail 구조일 경우 
                    delete를 처리할 SQL ID     
* @param saveFlagColumn  insertSql, updateSql, deleteSql이 존재하여 신규, 수정, 삭제를 
                         처리할 경우 기본적으로 Dataset의 getRowStates()로 판단하여 처리
                         하나 이를 Flag 컬럼으로 대체하고 싶은 경우 사용
                         해당 Flag 컬럼의 값은 신규 - I , 수정 - U , 삭제 - D의 값을 
                         가져야 한다. 
* @param keySqlName PK 조회용 SQL ID 
* @param keyIncrement keySqlName이 존재할 경우만 사용되며, 
                      반복적인 처리 Sql의 경우 다음 정보 key 증가 값 
                      현재는 integer 형의 숫자형 key만 처리 가능 
* @param callbackSql 처리가 완료된 후 결과로써 반환할 Sql Id      
* @param keyZeroLen  Key 에 0 채워야 할 경우 0 의 갯수         
* @param execType 처리해야 하는 실행타입 정의 ( B - 배치 , N - 한건 씩 처리 )
* @return 없음
******************************************************************/
fsp.addSave = function(
		insertSql
		, updateSql
	    , deleteSql
	    , saveFlagColumn
	    , keySqlName
	    , keyIncrement
	    , callbackSql
	    , keyZeroLen
	    , execType) {
	
	fsp.add("S" // txType
			, "" // sqlName 
			, keySqlName // keySqlName	
	        , keyIncrement	// keyIncrement
	        , callbackSql	// callbackSql
	        , insertSql	// insertSql
	        , updateSql	// updateSql
	        , deleteSql	// deleteSql
	        , saveFlagColumn	// saveFlagColumn
	        , keyZeroLen 		// keyZeroLen
	        , execType		// execType
	);
};
/**
 * 
 * @param actionName
 * @param cmdName
 * @param data
 * @param callbackFnc
 * @param isErrorNotCall
 * @param isNotShow
 * @param isSync
 * @param trId
 */
fsp.callService = function (
 		actionName
        , cmdName
        , data
        , callbackFnc
        , isErrorNotCall 
        , isNotShow
        , isSync) {
	
	// 데이터를 추가한다. 
	if( fsp.fsp_ds_cmd.length > 0 ) {
		data["fsp_ds_cmd"] = fsp.fsp_ds_cmd;
	}
	
	if( !actionName || actionName == "") {
		if( fsp.getCampus() == "S") {
			actionName = "xShaksaAction";
		} else {
			actionName = "xDefaultAction";
		}	
	}
	if( !cmdName || cmdName == "") {
		cmdName = "execute";
	}

	data["fsp_action"] = actionName;
	console.log(data["fsp_action"]);
	data["fsp_cmd"] = cmdName;
	$.ajax({
		type : 'POST'
		, url : fsp.serverUrl
		, cache : false
		, data : $.toJSON(data)
		, dataType : 'json'
		, contentType : 'application/json; charset=utf-8'
	//	, success : successFnc// end success
	//	, error : errorFnc // end error 
		, complete : function(xhr,textStatus) {
			fsp.watingLoad(false);
			var status =  xhr.status;
			
			if( status == 200 ) {
				eval("var msg = " +  xhr.responseText + ";");
				var errorCode =  msg.ErrorCode;
				if( errorCode != 0 ) {
					if( errorCode == -100 ) {
						// Business Exception 처리 : 메시지 처리하지 않음. 
					} else if( errorCode == -200) {
						// 로그인이 session 이 끈어진 경우 
			            fsp.fn_notLogin();
			            return;
					} else {
						if(msg.errorTrace) {
						//	fsp.fn_showSysError( msg.errorTrace );
							fsp.fn_showSysError("처리 도중 오류가 발생했습니다.\n잠시후 다시 처리해주십시오.");
						} else {
							fsp.fn_showSysError( msg.ErrorMsg );
						}
					}
					
					// 호출하기 
					if( isErrorNotCall !== true ) {
						if( callbackFnc ) {
							callbackFnc(errorCode, msg);
						}
					}
				} else {
					// 처리 성공 
					if( callbackFnc ) {
						callbackFnc(errorCode, msg);
					}
				}	
			} else {
				// 처리 실패 
				if( status == 12029 ) { // 12029 : server shutdown 
					alert("서버에 접속할 수 없습니다. 잠시 후 다시 요청해 주십시오.");
				} else if( status == 404 ) {
					alert("서버 접속 경로가 잘못 되었습니다. 경로를 확인해 주십시오.");
				} else {
					alert("서버 접속 중 처리에 실패했습니다.:" + status);
				}
			}	
		}	// end compelte
		, beforeSend : function() {
			if( !isNotShow ) {
				fsp.watingLoad(true);	
			}	
		}	// end beforeSend
	});
};

/******************************************************
*  로그인이 안되어 있을 경우 처리 
******************************************************/
fsp.fn_notLogin = function() {
	try {
		eval("fsp_fn_notLogin();");
	} catch( e ) {
		alert( "사용자 정보가 존재하지 않습니다." );
		
		try {
			if( opener ) {
				opener.parent.window.location = "index.html";
				self.close();
			}
		} catch ( ee ) {
			window.location = "index.html";
		}
	}	
};

/******************************************************
* 서버에서 처리한 후의 에러 메시지 창 표시 
******************************************************/
fsp.fn_showSysError = function( sMsg ) {
	try {
		eval("fsp_fn_showSysError( sMsg );");
	} catch( e ) {
		alert( sMsg );
	}
};

/**
 * 처리중입니다. 메시지 표시.<p>
 * 
 * @param state true 처리중입니다. 표시 
 */
fsp.watingLoad = function(state) {	
	var wating = $("#watingLoad");
	if(!wating) {
		var obj = $("<div id='watingLoad' style='display:none'>" + 
					"<p style='text-align:center; padding:0 0 0 0; left:50%; top:50%; position:absolute;'>" + 
					"<img src='/mobis/fspmob/images/loader.gif' alt='로딩중'/>" + 
					"</p>" +
					"</div>");
		
		$('body').prepend(obj);
		wating = $("#watingLoad");
	}
	
	// 처리 중 이미지를 표시한다. 
	if (state) {
	//	var y = 
	//		document.all ? (!document.all.scrollTop ? document.body.scrollTop : document.all.scrollTop) 
	//				: (window.pageYOffset ? window.pageYOffset : window.scrollY);
	//	wating.css("top",y);
		
		var bd = document.documentElement ? document.documentElement : document.body;
		var screenW = bd.scrollWidth;
		var scrollX = (window.pageXOffset ? window.pageXOffset : window.scrollX);
		if( !scrollX ) {
			scrollX = bd.scrollLeft;
		}
		var scrollY = (window.pageYOffset ? window.pageYOffset : window.scrollY);
		if( !scrollY ) {
			scrollY = bd.scrollTop;
		}
		
		wating.css("left", ((screenW+scrollX)/2)-10);
	//	wating.css("top", ((screenH+scrollY)/2)-10);
		wating.show();//.fadeIn('fast');
	} else {
		wating.fadeOut();
	}
};	// end watingLoad www

/**
 * 주어진 정보가 null 인지를 확인한다.<p>
 * @param obj
 * @return null 일 경우  true 
 * @returns {Boolean}
 */
fsp.isUndefined = function(obj) {
	return obj === undefined;
};
/**
 * 객체를 추가한다.<p>
 * @param func
 */
fsp.addConstructor = function(func) {    
    try {
        func();
    } catch(e) {
        console.log("Failed to run constructor: " + e);
    }
};
